\subsection{Instruction set architecture}

There is only quick explanation of meaning individual instruction. If you want
to see binary format, plese see file /doc/isa.ods.

\subsubsection{Program control instructions}

These instruction control program flow. In this group are instruction RET,
RETI, CALLI, BZI, BNZI, CALL, BZ, BNZ and SWI.

Instruction RETI is intended for returning from interrupt service routine. It
is necessary inform interrupt driver about completing the ISR. So, this is
reason why there is RETI.

Instruction RET, CALL and CALLI are for implementing subroutines. Instruction
CALL is similar to CALLI, both call subroutine and store return address into
stack. But instruction CALL excepting absolute address of subroutine.
Instruction CALLI, on the another hand, excepting register where the subroutine
address is stored. Instruction RET will take return address from stack and
continue normal program execution.

There are also instruction for conditional jumps. They are BZI, BNZI, BZ and
BNZ. BZ mean "branch zero" and BNZ mean "branch nonzero", suffix I mean where
address to jump is stored. If there is I in instruction, address is stored in
some register, instruction without I have address in their instruction word.

There isn't any flags for conditional jumps, for example, instruction BZ jump
when in specified register is zero, if there is another value, it will continue
without jumping.

SWI instruction is quiet special one. It is used to generate software interrupt.
This can be used in implementation of operating system to transfer control from
user space program to the kernel.

\subsubsection{Memory instructions}

These instruction work with memory. They are LD, LDI, ST, STI, PUSH and POP.

PUSH and POP are instruction for stack operation. PUSH save data from specified
register into stack and decrement stack pointer. POP instruction increment
stack pointer and then store data from stack into specified register.

Instruction LD and LDI load data from memory into specified register. Memory is
organized as 32b words and these instruction work only with 32b words.
Instruction LD have address in it's instruction word and LDI use address from
specified register.

Instruction ST and STI are similar to LD and LDI, but they are load data into
memory.

\subsubsection{Data move instructions}

Instruction that are intended for moving data. There are only four instruction
of this type. First is MOV. MOV instruction move data from one register into
another. Actually, copy from one register into another.

Another two instruction from this group are MVIH and MVIL. Both are intended
for loading immediate values into register, but because there are 32bit
register, instruction are 32bit wide and there have to be space for opcode in
instruction word, MVI instruction is splitted into MVIH and MVIL. MVIL will
load lower 16b into specified register and MVIH upper 16bit.

Last instruction for moving is MVIA. MVIA is similar to MVIL and MVIH, but
constant for loading is 24bit wide. Because address bus of MARK II CPU is 24bit
wide, this instruction is perfect for loading address into registers.

\subsubsection{Computation instructions}

These instruction are intended for computation on the data. MARK II CPU use
three operand arithmetic, so you have to specify three register, two for
operand, and one for result. But, there are also few instruction where only one
operand is used, for example increment instruction.

CPU is able to do basic bitwise operations, concretely AND, OR, XOR and NOT.
There are also ADD and SUB instruction for adding and subtracting, MUL and MULU
for signed and unsigned multiplication, DIV and DIVU for signed and unsigned
integer division, REM and REMU for signed and unsigned integer division remainder.

CPU also have floating point unit. In order to make computation on floats there
are instruction FADD, FSUB, FDIV and FMUL for adding, subtracting, division
and multiplication.

Instructions INC and DEC are used for incrementing and decrementing registers,
these instruction use only two operands, one for input operand and second for
result.

There are also shifting instructions LSL, LSR, ROL, ROR, ASL and ASR. LSL for
logical shift to left, LSR for logical shift to right, ROL for rotate to left,
ROR for rotate to right, ASL for arithmetic shift left and ASR for arithmetic
shift right. You can also specify distance from 0 to 31. All shifts and rotations
are done using single cycle barrel shifter.

\subsubsection{Special instructions}

Currently there is only one special instruction and that is CMP. This
instruction is mandatory for branching. With this instruction you can compare
two register with specified comparison type and store 1 if "expression" is true
or 0 if false, into specified register.

\subsubsection{More informations}

You can find more informations about instruction format in document called
MARK-II Instruction Set Architecture.
